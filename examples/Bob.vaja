fn new() -> {"routes": [], "middlewares": []}

let newJSONResponse = HashMap.insert("render", JSON.toJSON)

fn newPath(path)
  "^" ++ path ++ "$" |> String.split("/") |> String.join("\/") |> Regex.fromString()
end

fn newRedirect(status, url) -> {
  "response": true,
  "headers": [["location", url]],
  "status": status
}

let addMiddlewares = HashMap.insert("middlewares")
let addRoutes = HashMap.insert("routes")
let addRoute404 = HashMap.insert("route404")

let isResponse = HashMap.hasKey("response")

fn makeHandler(app)
  fn (req)
    let expandedMiddlewares = Array.map(fn (x) -> x(), app.middlewares)

    let updatedReq = \
      expandedMiddlewares \
      |> Array.map(Array.head) \
      |> Array.reduce(fn(acc, curr)
        if (isResponse(acc)) acc else curr(acc) end
      end, req)

    if (isResponse(updatedReq))
      return updatedReq
    end

    let matchingRoutes = matchRoute(app.routes, req)
    let [route, routeArgs] = \
      if (Array.len(matchingRoutes) > 0)
        let [regex, handler] = \
          matchingRoutes |> Array.head()

        [handler, Regex.find(regex, req.path)]
      else
        [app.route404, []]
      end

    expandedMiddlewares \
    |> Array.map(Array.last) \
    |> Array.reduce(
      fn(acc, curr) -> curr(acc),
      route(updatedReq, routeArgs)
    )
  end
end

fn matchRoute(routes, req)
  routes |> Array.filter(fn(route) -> Regex.contains(route[0], req.path))
end


# Middlewares

fn enforceTrailingSlashMiddleware()
  let processReq = fn(req)
    if (String.right(1, req.path) != "/")
      newRedirect(302, req.path ++ "/")
    else
      req
    end
  end
  [processReq, identity]
end

fn debugMiddleware()
  let processReq = fn(req)
    print("-- Request --" ++ req.path)
    print(req)
    req
  end
  let processResp = fn (res)
    print("-- Response --")
    print(res)
    res
  end

  [processReq, processResp]
end

fn rendererMiddleware()
  let processResp = fn (res)
    if HashMap.hasKey("render", res)
      res |> HashMap.insert("body", res.render(res.context))
    else
      res
    end
  end

  [identity, processResp]
end
